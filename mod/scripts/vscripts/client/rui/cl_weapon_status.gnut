global function ClWeaponStatus_Init
global function ClWeaponStatus_SetOffhandVisible
global function ClWeaponStatus_SetWeaponVisible
global function ClWeaponStatus_GetWeaponHudRui
global function ClWeaponStatus_RefreshWeaponStatus
global function GetAccentColor

struct
{
	var ammo_status_hint
	var ability_left_hud
	var ability_center_hud
	var ability_right_hud
	var dpad_left_hud
	var ammo_counter

	bool[6] slotVisible = [true, true, true, true, true, true]
	bool ammo_counter_visible = true

	int lastSelectedIndex

	// GtJt HUD
	array< void functionref( float ) > updateCallbacks
	array< void functionref() > startCallbacks
	table<string, var> ruis
	table<string, bool> phaseState // is player phaseShifting
	table<string, bool> phaseGlitching
	table<string, float> estimatedPSEndTime
	// GtJt HUD
} file

// GtJt HUD
global enum eDirection
{
    down,
    up,
    left,
    right
}

global struct TopoData {
    vector position = Vector( 0.0, 0.0, 0.0 )
    vector size = Vector( 0.0, 0.0, 0.0 )
    vector angles = Vector( 0.0, 0.0, 0.0 )
    var topo
}

global struct BarTopoData {
    vector position = Vector( 0.0, 0.0, 0.0 )
    vector size = Vector( 0.0, 0.0, 0.0 )
    vector angles = Vector( 0.0, 0.0, 0.0 )
    int segments = 1
	float segmentDistance
    array<var> imageRuis
    array<TopoData> topoData
    int direction
	float fill
	bool isFlat = false
}

struct {
    string abilityText = "%.1f"
} settings
// GtJt HUD

void function ClWeaponStatus_Init()
{
	AddCallback_OnClientScriptInit( ClWeaponStatus_AddClient )
	AddCallback_OnSelectedWeaponChanged( OnSelectedWeaponChanged )

	AddCallback_OnPlayerLifeStateChanged( OnLifeStateChanged )
	AddCallback_PlayerClassChanged( OnPlayerClassChanged )

	AddCallback_KillReplayEnded( OnKillReplayEnded )

	RegisterSignal( "EndTrackOffhandWeaponSlot" )
}

void function ClWeaponStatus_RefreshWeaponStatus( entity player )
{
	if ( !IsValid( player ) )
		return

	UpdatePrimaryWeaponHint()

	if ( !IsValid( GetLocalViewPlayer() ) )
		return

	InitWeaponStatusRuis( GetLocalViewPlayer() )
}

var function ClWeaponStatus_GetWeaponHudRui( entity player, entity weapon )
{
	var index = weapon.GetWeaponInfoFileKeyField( "offhand_default_inventory_slot" )

	if ( index == null )
		return file.ammo_counter

	expect int( index )

	return GetRuiForIndex( player, index )
}

// GtJt HUD
void function AddStartCallback( void functionref() callback )
{
	file.startCallbacks.append(callback)
}

void function AddUpdateCallback( void functionref( float ) callback )
{
	file.updateCallbacks.append(callback)
}

void function Start()
{
	foreach(void functionref() f in file.startCallbacks){
		f()
	}
}

void function UpdateThread()
{
	float time = Time()
	while (true)
	{
		time = Time()
		WaitFrame()
		if (IsWatchingKillReplay()) continue
		foreach(void functionref(float) f in file.updateCallbacks){
			f(Time() - time)
		}
		//while (IsWatchingKillReplay()) { WaitFrame(); }
	}
}
// GtJt HUD

void function ClWeaponStatus_AddClient( entity player )
{
	{
		var rui = CreateCockpitRui( $"ui/ammo_status_hint.rpak" )
		RuiTrackFloat( rui, "ammoFrac", GetLocalClientPlayer(), RUI_TRACK_WEAPON_CLIP_AMMO_FRACTION )
		RuiTrackFloat( rui, "remainingAmmoFrac", GetLocalClientPlayer(), RUI_TRACK_WEAPON_REMAINING_AMMO_FRACTION )
		RuiTrackFloat( rui, "readyToFireFrac", GetLocalClientPlayer(), RUI_TRACK_WEAPON_READY_TO_FIRE_FRACTION )
		RuiTrackFloat( rui, "reloadingFrac", GetLocalClientPlayer(), RUI_TRACK_WEAPON_RELOAD_FRACTION )

		file.ammo_status_hint = rui
	}

	{
		var rui = CreateCockpitRui( $"ui/ability_hud.rpak" )
		RuiSetInt( rui, "xPos", 0 )
		file.ability_left_hud = rui
	}

	{
		var rui = CreateCockpitRui( $"ui/ability_hud.rpak" )
		RuiSetInt( rui, "xPos", 1 )
		file.ability_center_hud = rui
	}

	{
		var rui = CreateCockpitRui( $"ui/ability_hud.rpak" )
		RuiSetInt( rui, "xPos", 2 )
		file.ability_right_hud = rui
	}

	{
		var rui = CreateCockpitRui( $"ui/inventory_hud.rpak" )
		RuiSetInt( rui, "xPos", 1 )
		RuiSetInt( rui, "yPos", 1 )
		file.dpad_left_hud = rui
	}

	{
		var rui = CreateCockpitRui( $"ui/ammo_counter.rpak" )
		file.ammo_counter = rui
	}

	// GtJt HUD
	AddStartCallback( InitAdditionalRuis )
	Start()
	thread UpdateThread()
}

// GtJt HUD
void function InitAdditionalRuis()
{
	//offhands
	{
		var rui = RuiCreate( $"ui/cockpit_console_text_center.rpak", clGlobal.topoCockpitHud, RUI_DRAW_COCKPIT, 5 )
		RuiSetInt( rui, "maxLines", 1 )
		RuiSetInt( rui, "lineNum", 0 )
		RuiSetFloat2( rui, "msgPos", GetConVarFloat2("comp_hud_ordnance_position") + GetConVarFloat2("comp_hud_ability_cooldown_pos_offset") )
		RuiSetString( rui, "msgText", "5" )
		RuiSetFloat( rui, "msgFontSize", 32.0 )
		RuiSetFloat3( rui, "msgColor", GetAccentColor() )
		RuiSetFloat( rui, "msgAlpha", 0.9 )
		RuiSetFloat( rui, "thicken", -0.25 )
		file.ruis["offhand0"] <- rui
	}

	{
		var rui = RuiCreate( $"ui/cockpit_console_text_center.rpak", clGlobal.topoCockpitHud, RUI_DRAW_COCKPIT, 5 )
		RuiSetInt( rui, "maxLines", 1 )
		RuiSetInt( rui, "lineNum", 0 )
		RuiSetFloat2( rui, "msgPos", GetConVarFloat2("comp_hud_tactical_position") + GetConVarFloat2("comp_hud_ability_cooldown_pos_offset") )
		RuiSetString( rui, "msgText", "3" )
		RuiSetFloat( rui, "msgFontSize", 32.0 )
		RuiSetFloat3( rui, "msgColor", GetAccentColor() )
		RuiSetFloat( rui, "msgAlpha", 0.9 )
		RuiSetFloat( rui, "thicken", -0.25 )
		file.ruis["offhand1"] <- rui
	}

	{
		var rui = RuiCreate( $"ui/cockpit_console_text_center.rpak", clGlobal.topoCockpitHud, RUI_DRAW_COCKPIT, 5 )
		RuiSetInt( rui, "maxLines", 1 )
		RuiSetInt( rui, "lineNum", 0 )
		RuiSetFloat2( rui, "msgPos", GetConVarFloat2("comp_hud_utility_position") + GetConVarFloat2("comp_hud_ability_cooldown_pos_offset") )
		RuiSetString( rui, "msgText", "0.9" )
		RuiSetFloat( rui, "msgFontSize", 32.0 )
		RuiSetFloat3( rui, "msgColor", GetAccentColor() )
		RuiSetFloat( rui, "msgAlpha", 0.9 )
		RuiSetFloat( rui, "thicken", -0.25 )
		file.ruis["offhand2"] <- rui
	}

	// speedo
	{
		var rui = RuiCreate( $"ui/cockpit_console_text_top_left.rpak", clGlobal.topoCockpitHud, RUI_DRAW_COCKPIT, 5 )
		RuiSetInt( rui, "maxLines", 1 )
		RuiSetInt( rui, "lineNum", 1 )
		RuiSetFloat2( rui, "msgPos", GetConVarFloat2("comp_hud_wpd_pos") )
		RuiSetString( rui, "msgText", "BOOST" )
		RuiSetFloat( rui, "msgFontSize", GetConVarFloat("comp_hud_wpd_size") )
		RuiSetFloat3( rui, "msgColor", GetConVarFloat3("comp_hud_wpd_color")/255.0 )
		RuiSetFloat( rui, "msgAlpha", 0.9 )
		RuiSetFloat( rui, "thicken", -0.25 )
		file.ruis["speed"] <- rui
	}

	// phase glitch detector
	{
		var rui = RuiCreate( $"ui/cockpit_console_text_top_left.rpak", clGlobal.topoCockpitHud, RUI_DRAW_COCKPIT, 5 )
		RuiSetInt( rui, "maxLines", 1 )
		RuiSetInt( rui, "lineNum", 1 )
		RuiSetFloat2( rui, "msgPos", GetConVarFloat2("comp_phase_glitch_detector_pos") )
		RuiSetString( rui, "msgText", "Glitch" )
		RuiSetFloat( rui, "msgFontSize", GetConVarFloat("comp_phase_glitch_detector_size") )
		RuiSetFloat3( rui, "msgColor", <1.0, 0.0, 0.0> )
		RuiSetFloat( rui, "msgAlpha", 0.9 )
		RuiSetFloat( rui, "thicken", -0.25 )
		file.ruis["glitch"] <- rui
	}

	AddUpdateCallback( UpdateAdditionalRuis )
}

bool isWR = false
int WRFrames = 0
float startWRSpeed = 0.0
float endWRSpeed = 0.0
float lastSpeed = 0.0
void function UpdateAdditionalRuis( float deltaTime )
{
	entity player = GetLocalViewPlayer()
	if (!IsValid(player) || !player.IsPlayer()) return

	if (clGlobal.isMenuOpen)
	{
		MenuOpen()
		return
	}

	// update speedometer
	if (GetConVarBool("comp_hud_wpd") && !player.IsTitan())
	{
		RuiSetFloat3( file.ruis["speed"], "msgColor", GetConVarFloat3("comp_hud_wpd_color")/255.0 )
		RuiSetString(file.ruis["speed"], "msgText", format( "%.1f km/h",  Length( Vector( player.GetVelocity().x, player.GetVelocity().y, 0 ) / 10.9444 ) ) )
		RuiSetFloat(file.ruis["speed"], "msgFontSize", GetConVarFloat("comp_hud_wpd_size"))
		RuiSetFloat2(file.ruis["speed"], "msgPos", GetConVarFloat2("comp_hud_wpd_pos"))
		if (player.IsWallRunning())
		{
			if (!isWR)
			{
				WRFrames = 0
				isWR = true
				startWRSpeed = lastSpeed
			}
			WRFrames++
			RuiSetString(file.ruis["speed"], "msgText", "frames: " + WRFrames + "\n" +
			format( "%.1f km/h", Length( Vector( player.GetVelocity().x, player.GetVelocity().y, 0 ) / 10.9444 ) ) )
		}
		else {
			if (isWR) endWRSpeed = Length( Vector( player.GetVelocity().x, player.GetVelocity().y, 0 ) )
			isWR = false
			RuiSetString(file.ruis["speed"], "msgText", "frames: " + WRFrames + "\n" +
			format( "%.1f km/h (%+.1f)", Length( Vector( player.GetVelocity().x, player.GetVelocity().y, 0 ) / 10.9444 ), (endWRSpeed - startWRSpeed) / 10.9444 ) )

			lastSpeed = Length( Vector( player.GetVelocity().x, player.GetVelocity().y, 0 ) )
		}
	}
	else
		RuiSetString(file.ruis["speed"], "msgText", "")

	// update equipments cooldown
	for (int i = 0; i < 3; i++)
	{
		var rui = file.ruis["offhand" + i]
		RuiSetFloat3(rui, "msgColor", GetAccentColor() )
		RuiSetFloat( rui, "msgAlpha", GetConVarBool("comp_hud_ability_cooldown") ? 0.9 : 0.0 )
		if (!IsValid(player.GetOffhandWeapon(i)))
		{
			RuiSetString(rui, "msgText", "")
		}
		else if(!player.IsTitan())
		{
			string posConVar = "comp_hud_ordnance_position"
			switch (i)
			{
				case 1:
					posConVar = "comp_hud_tactical_position"
					break
				case 2:
					posConVar = "comp_hud_utility_position"
					break
			}
			RuiSetFloat2( rui, "msgPos", GetConVarFloat2(posConVar) + GetConVarFloat2("comp_hud_ability_cooldown_pos_offset") )

			UpdateOffhandRui(rui, player, player.GetOffhandWeapon(i))
		}
		else
		{
			string posConVar = "comp_hud_utility_position"
			switch (i)
			{
				case 1:
					posConVar = "comp_hud_tactical_position"
					break
				case 2:
					posConVar = "comp_hud_ordnance_position"
					break
			}
			RuiSetFloat2( rui, "msgPos", GetConVarFloat2(posConVar) + GetConVarFloat2("comp_hud_ability_cooldown_pos_offset") )

			UpdateOffhandRui(rui, player, player.GetOffhandWeapon(i))
		}
	}

	// update phase glitch detector
	if (GetConVarBool("comp_phase_glitch_detector"))
	{
		RuiSetFloat( file.ruis["glitch"], "msgAlpha", 0.9)
		RuiSetFloat( file.ruis["glitch"], "msgFontSize", GetConVarFloat("comp_phase_glitch_detector_size"))
		array<entity> players = GetPlayerArray()
		string detectMsg = ""
		foreach ( thisPlayer in players )
		{
			string playerName_ = thisPlayer.GetPlayerName()
			if (IsValid(thisPlayer) && thisPlayer.IsPlayer())
			{
				if (IsAlive(thisPlayer))
				{
					if (thisPlayer.IsPhaseShifted())
					{
						float curTime = Time()
						if (!file.phaseState[playerName_])
						{
							printt(format("%s is phase shifting at %.3f!", playerName_, curTime))
							file.phaseState[playerName_] <- true // start counting
							if (player.IsTitan())
							{
								// TODO 瞬间反应？
								file.estimatedPSEndTime[playerName_] <- curTime + 1.0
							}
							else
							{
								file.estimatedPSEndTime[playerName_] <- curTime + 2.0
							}
						}
						else if (curTime > file.estimatedPSEndTime[playerName_])
						{
							printt(format("%s is phase glitching at %.3f!", playerName_, curTime))
							file.phaseGlitching[playerName_] <- true
						}
					}
					else
					{
						// if (file.phaseState[playerName_])
						// {
						// 	float curTime = Time()
						// 	printt(format("%s exits phase shifting at %.3f!", playerName_, curTime))
						// }
						file.phaseState[playerName_] <- false
						file.phaseGlitching[playerName_] <- false // init
					}
				}
				else
				{
					// printt(format("%s is dead!\n", playerName_))
					file.phaseGlitching[playerName_] <- false // clear on death
				}
				if (playerName_ in file.phaseGlitching)
				{
					if (file.phaseGlitching[playerName_])
					{
						detectMsg += format("%s is phase glitching!\n", playerName_)
					}
				}
			}
		}
		RuiSetString(file.ruis["glitch"], "msgText", detectMsg)
	}
	else
	{
		RuiSetFloat( file.ruis["glitch"], "msgAlpha", 0.0 )
	}
}

void function MenuOpen()
{
		//offhands
		{
			RuiSetFloat2( file.ruis["offhand0"], "msgPos", GetConVarFloat2("comp_hud_ordnance_position") + GetConVarFloat2("comp_hud_ability_cooldown_pos_offset") )
			RuiSetString( file.ruis["offhand0"], "msgText", "2.0" )
			RuiSetFloat3( file.ruis["offhand0"], "msgColor", GetAccentColor() )
			RuiSetFloat( file.ruis["offhand0"], "msgAlpha", 0.9 )
		}

		{
			RuiSetFloat2( file.ruis["offhand1"], "msgPos", GetConVarFloat2("comp_hud_tactical_position") + GetConVarFloat2("comp_hud_ability_cooldown_pos_offset") )
			RuiSetString( file.ruis["offhand1"], "msgText", "1.0" )
			RuiSetFloat3( file.ruis["offhand1"], "msgColor", GetAccentColor() )
			RuiSetFloat( file.ruis["offhand1"], "msgAlpha", 0.9 )
		}

		{
			RuiSetFloat2( file.ruis["offhand2"], "msgPos", GetConVarFloat2("comp_hud_utility_position") + GetConVarFloat2("comp_hud_ability_cooldown_pos_offset") )
			RuiSetString( file.ruis["offhand2"], "msgText", "3.0" )
			RuiSetFloat3( file.ruis["offhand2"], "msgColor", GetAccentColor() )
			RuiSetFloat( file.ruis["offhand2"], "msgAlpha", 0.9 )
		}

		// speedo
		{
			RuiSetFloat2( file.ruis["speed"], "msgPos", GetConVarFloat2("comp_hud_wpd_pos") )
			RuiSetString( file.ruis["speed"], "msgText", "frames: " + 59 + "\n" + format( "%.1f km/h (%+.1f)", 33.33, 8.88 ))
			RuiSetFloat( file.ruis["speed"], "msgFontSize", GetConVarFloat("comp_hud_wpd_size") )
			RuiSetFloat3( file.ruis["speed"], "msgColor", GetConVarFloat3("comp_hud_wpd_color")/255.0 )
			RuiSetFloat( file.ruis["speed"], "msgAlpha", 0.9 )
		}

		// phase glitch detector
		{
			RuiSetFloat2( file.ruis["glitch"], "msgPos", GetConVarFloat2("comp_phase_glitch_detector_pos") )
			RuiSetString( file.ruis["glitch"], "msgText", "[Player] Possible Phase Glitch Detected" )
			RuiSetFloat( file.ruis["glitch"], "msgFontSize", GetConVarFloat("comp_phase_glitch_detector_size") )
			RuiSetFloat( file.ruis["glitch"], "msgAlpha", 0.9 )
		}
}

void function UpdateOffhandRui( var rui, entity player, entity weapon )
{
	float altCooldown = 0.0
	float timeUntilNextCharge = 0.0
	int maxCharges = 1
	float minFracToUse = 1
	bool doNotSetText = false
	float ammoFrac = 0
	if (weapon.IsChargeWeapon()) ammoFrac = 1 - weapon.GetWeaponChargeFraction()
	if (weapon.GetWeaponPrimaryClipCountMax() > 0) ammoFrac = float(weapon.GetWeaponPrimaryClipCount()) / weapon.GetWeaponPrimaryClipCountMax()
	switch ( weapon.GetWeaponInfoFileKeyField( "cooldown_type" ) )
	{
		case "ammo_swordblock":
			ammoFrac = 0
			timeUntilNextCharge = 0
			altCooldown = 0
			break

		case "shared_energy":
			int curCost = weapon.GetWeaponCurrentEnergyCost() // 350
			float energy = float( player.GetSharedEnergyCount() )
			float maxEnergy = float( player.GetSharedEnergyTotal() ) // 1000
			float energyRegenRate = player.GetSharedEnergyRegenRate()

			maxCharges = int( maxEnergy ) / curCost
			minFracToUse = float( curCost ) / maxEnergy
			int curCharges = int( energy ) / curCost
			int targetAmmo = (curCharges + 1) * curCost
			timeUntilNextCharge = (targetAmmo - energy) / energyRegenRate
			ammoFrac = (energy / curCost / maxCharges)

			// Ability - 2/2 | 2.5s
			break

		case "shared_energy_drain":
			float energy = float( player.GetSharedEnergyCount() )
			float maxEnergy = float( player.GetSharedEnergyTotal() ) // 1000
			float energyRegenRate = player.GetSharedEnergyRegenRate()
			maxCharges = 1

			minFracToUse = 0.1
			timeUntilNextCharge = (maxEnergy - energy) / energyRegenRate
			ammoFrac = (energy / maxEnergy)


			if (player.GetActiveWeapon() == weapon)
			{
				timeUntilNextCharge = (energy / maxEnergy) * weapon.GetWeaponSettingFloat( eWeaponVar.charge_time )
			}
			break

		case "vortex_drain":
			// display percentage/cooldown
			break

		case "charged_shot":
			float chargeCooldownTime = weapon.GetWeaponSettingFloat( eWeaponVar.charge_cooldown_time )
			timeUntilNextCharge = (1 - ammoFrac) * chargeCooldownTime
			ammoFrac = 1 - weapon.GetWeaponChargeFraction()
			switch (weapon.GetWeaponClassName())
			{
				case "mp_titanweapon_shoulder_rockets":
					minFracToUse = 0.2
					break;
				case "mp_titanweapon_vortex_shield":
					minFracToUse = 0.1
					break;
				default:
					minFracToUse = 1
			}
			break

		case "grapple":
			int ammoClipSize = 100
			float ammoMinToFire = weapon.GetWeaponSettingFloat( eWeaponVar.grapple_power_required )
			float grapplePower = player.GetSuitGrapplePower()
			float grappleRegenRate = 3.0

			if (player.HasPassive( ePassives.PAS_POWER_CELL ))
			{
				// AAAAAAAAAAAA
				grappleRegenRate *= 1.35
			}

			try
			{
				maxCharges = ammoClipSize / int(ammoMinToFire)
			}
			catch (ex) { maxCharges = 1 }
			minFracToUse = ammoMinToFire / ammoClipSize
			if (ammoMinToFire > 0) maxCharges = ammoClipSize / int( ammoMinToFire )
			int curCharges = 0;
			if (ammoMinToFire > 0) curCharges = int( grapplePower ) / int( ammoMinToFire )
			int targetAmmo = (curCharges + 1) * int( ammoMinToFire )
			timeUntilNextCharge = (targetAmmo - grapplePower) / grappleRegenRate
			if (GameRules_GetGameMode() == "econ")
				timeUntilNextCharge = 0.0
			if (ammoClipSize == grapplePower) timeUntilNextCharge = 0
			ammoFrac = grapplePower / ammoClipSize

			break

		case "ammo_instant":
			int cost = weapon.GetWeaponSettingInt( eWeaponVar.shared_energy_cost )
			if (cost > 0)
			{
				float energy = float( player.GetSharedEnergyCount() )
				if (energy < cost)
				{
					float energyRegenRate = player.GetSharedEnergyRegenRate()
					float timeUntilNextCharge = (cost - energy) / energyRegenRate
					if (timeUntilNextCharge > altCooldown)
						altCooldown = timeUntilNextCharge
				}
			}
		default:
			float refillRate = weapon.GetWeaponSettingFloat( eWeaponVar.regen_ammo_refill_rate )

			float timeUntilNextAttack = weapon.GetNextAttackAllowedTime() - Time()
			if (weapon.GetWeaponSettingFloat( eWeaponVar.fire_duration ) > 0)
			{
				if (timeUntilNextAttack > 1 / weapon.GetWeaponSettingFloat( eWeaponVar.fire_rate ))
				{
					timeUntilNextCharge = timeUntilNextAttack - 1 / weapon.GetWeaponSettingFloat( eWeaponVar.fire_rate )
					break
				}
			}
			if (timeUntilNextAttack > altCooldown)
			{
				altCooldown = timeUntilNextAttack
			}
			if ( refillRate > 0 || !weapon.IsChargeWeapon())
			{
				//printt( "HUD: ", weapon.GetWeaponClassName(), "using", "refillRate" )
				int ammoClipSize = weapon.GetWeaponSettingInt( eWeaponVar.ammo_clip_size )
				// returns MP setting despite it being 1
				int ammoMinToFire = weapon.GetWeaponSettingInt( eWeaponVar.ammo_min_to_fire )
				//printt(weapon.GetWeaponSettingString(eWeaponVar.printname), "| max ammo:", ammoClipSize, "min to fire:", ammoMinToFire)

				maxCharges = ammoClipSize / ammoMinToFire
				minFracToUse = float( ammoMinToFire ) / ammoClipSize
				int curCharges = weapon.GetWeaponPrimaryClipCount() / ammoMinToFire
				int targetAmmo = (curCharges + 1) * ammoMinToFire
				if (refillRate > 0)
					timeUntilNextCharge = float(targetAmmo - weapon.GetWeaponPrimaryClipCount()) / refillRate
				else timeUntilNextCharge = 0.0
				if (ammoClipSize == weapon.GetWeaponPrimaryClipCount()) timeUntilNextCharge = 0


			}
			else
			{
				float chargeCooldownTime = weapon.GetWeaponSettingFloat( eWeaponVar.charge_cooldown_time )
				timeUntilNextCharge = (1 - ammoFrac) * chargeCooldownTime
				switch (weapon.GetWeaponClassName())
				{
					case "mp_titanweapon_shoulder_rockets":
						minFracToUse = 0.2
						break;
					case "mp_titanweapon_vortex_shield":
						minFracToUse = 0.1
						break;
					default:
						minFracToUse = 1
				}
			}
			break
	}

	float cooldown = max(timeUntilNextCharge, altCooldown)

	if (!doNotSetText) RuiSetString(rui, "msgText", format(settings.abilityText, cooldown))


	if (cooldown == 0.0)
		RuiSetString(rui, "msgText", "")
}


// GtJt HUD

void function OnSelectedWeaponChanged( entity selectedWeapon )
{
	if ( !IsValid( selectedWeapon ) )
	{
		RuiSetFloat( file.ammo_status_hint, "lowAmmoFrac", 0.0 )
		RuiSetBool( file.ammo_counter, "isVisible", false )
		return
	}

	if ( GetLocalViewPlayer().PlayerMelee_IsAttackActive() )
		return

	if ( GetLocalViewPlayer().IsUsingOffhandWeapon() )
		return

	asset primaryIcon = $""
	asset secondaryIcon = $""
	asset tertiaryIcon = $""
	array<entity> mainWeapons = GetLocalViewPlayer().GetMainWeapons()
	#if MP
		int activeIndex
		foreach ( index, weapon in mainWeapons )
		{
			asset hudIcon = GetWeaponInfoFileKeyFieldAsset_WithMods_Global( weapon.GetWeaponClassName(), weapon.GetMods(), "hud_icon" )
			if ( index == 0 )
				primaryIcon = hudIcon
			else if ( index == 1 )
				secondaryIcon = hudIcon
			else if ( index == 2 )
				tertiaryIcon = hudIcon

			if ( weapon == selectedWeapon )
				activeIndex = index
		}

		if ( activeIndex == 0 )
		{
			RuiSetImage( file.ammo_counter, "tertiaryHudIcon", tertiaryIcon )
			RuiSetImage( file.ammo_counter, "secondaryHudIcon", secondaryIcon )
			RuiSetGameTime( file.ammo_counter, "tapPingTime", Time() )
		}
		else if ( activeIndex == 1 )
		{
			RuiSetImage( file.ammo_counter, "tertiaryHudIcon", tertiaryIcon )
			RuiSetImage( file.ammo_counter, "secondaryHudIcon", primaryIcon )
			RuiSetGameTime( file.ammo_counter, "tapPingTime", Time() )
		}
		else if ( activeIndex == 2 )
		{
			if ( file.lastSelectedIndex == 0 )
			{
				RuiSetImage( file.ammo_counter, "tertiaryHudIcon", $"" )
				RuiSetImage( file.ammo_counter, "secondaryHudIcon", primaryIcon )
			}
			else if ( file.lastSelectedIndex == 1 )
			{
				RuiSetImage( file.ammo_counter, "tertiaryHudIcon", $"" )
				RuiSetImage( file.ammo_counter, "secondaryHudIcon", secondaryIcon )
			}
		}

		file.lastSelectedIndex = activeIndex
	#else
		foreach ( weapon in mainWeapons )
		{
			if ( weapon == selectedWeapon )
				continue

			if ( selectedWeapon.GetWeaponType() == WT_ANTITITAN )
				continue

			if ( weapon.GetWeaponType() == WT_ANTITITAN )
				continue

			if ( GetLocalViewPlayer().IsTitan() )
				continue

			asset hudIcon = GetWeaponInfoFileKeyFieldAsset_WithMods_Global( weapon.GetWeaponClassName(), weapon.GetMods(), "hud_icon" )
			secondaryIcon = hudIcon
		}
		RuiSetImage( file.ammo_counter, "secondaryHudIcon", secondaryIcon )
		RuiSetImage( file.ammo_counter, "tertiaryHudIcon", $"" )
	#endif

	InitAmmoCounterRui( file.ammo_counter, GetLocalViewPlayer(), selectedWeapon )

	float lowAmmoFrac = selectedWeapon.GetWeaponSettingFloat( eWeaponVar.low_ammo_fraction )
	RuiSetFloat( file.ammo_status_hint, "lowAmmoFrac", lowAmmoFrac )
	RuiSetBool( file.ammo_counter, "isVisible", file.ammo_counter_visible )
	RuiSetBool( file.ammo_counter, "isTitan", GetLocalViewPlayer().IsTitan() )

	RuiSetBool( file.ammo_counter, "isWeaponAmped", selectedWeapon.GetWeaponSettingBool( eWeaponVar.is_burn_mod ) )

	UpdatePrimaryWeaponHint()
}

void function UpdatePrimaryWeaponHint()
{
	// Show/Hide the BT loudout switch button hint if single player
	if ( IsSingleplayer() && GetLocalViewPlayer().IsTitan() && GetConVarInt( "hud_setting_showButtonHints" ) != 0 )
		RuiSetString( file.ammo_counter, "hintText", Localize( "#HUD_SP_BT_LOADOUT_SWAP" ) )
	else
		RuiSetString( file.ammo_counter, "hintText", "" )
}


void function InitAmmoCounterRui( var rui, entity player, entity weapon )
{
	RuiTrackFloat( rui, "maxMagAmmo", player, RUI_TRACK_WEAPON_CLIP_AMMO_MAX )
	RuiTrackFloat( rui, "maxStockpileAmmo", player, RUI_TRACK_WEAPON_STOCKPILE_AMMO_MAX )
	RuiTrackFloat( rui, "clipAmmoFrac", player, RUI_TRACK_WEAPON_CLIP_AMMO_FRACTION )
	RuiTrackFloat( rui, "remainingAmmoFrac", player, RUI_TRACK_WEAPON_REMAINING_AMMO_FRACTION )
	RuiTrackFloat( rui, "lifetimeShots", player, RUI_TRACK_WEAPON_LIFETIME_SHOTS )
	RuiTrackFloat( rui, "ammoRegenRate", player, RUI_TRACK_WEAPON_AMMO_REGEN_RATE )

	RuiTrackImage( rui, "hudIcon", player, RUI_TRACK_WEAPON_HUD_ICON )
}


void function OnPlayerClassChanged( entity player )
{
	if ( player != GetLocalViewPlayer() )
		return

	InitWeaponStatusRuis( player )
}


void function OnLifeStateChanged( entity player, int oldLifeState, int newLifeState )
{
	if ( player != GetLocalViewPlayer() )
		return

	if ( newLifeState != LIFE_ALIVE )
		return

	InitWeaponStatusRuis( player )
}

void function OnKillReplayEnded()
{
	entity player = GetLocalViewPlayer()

	InitWeaponStatusRuis( player )
}

void function UpdateOffhandRuis( entity player )
{
	UpdateOffhandRuiVisibility( file.ability_left_hud, "%offhand1%" )

	if ( player.IsTitan() )
		UpdateOffhandRuiVisibility( file.ability_center_hud, "%offhand2%" )
	else
		UpdateOffhandRuiVisibility( file.ability_center_hud, "%offhand0%" )

	UpdateOffhandRuiVisibility( file.ability_right_hud, "%offhand0%" )

	if ( IsMultiplayer() )
	{
		// need to recreate this since RuiTrackInt cannot be undone with RuiSetInt
		RuiDestroy( file.dpad_left_hud )
		var rui = CreateCockpitRui( $"ui/inventory_hud.rpak" )
		RuiSetInt( rui, "xPos", 1 )
		RuiSetInt( rui, "yPos", 1 )
		file.dpad_left_hud = rui
		UpdateOffhandRuiVisibility( file.dpad_left_hud, "%offhand4%" )
	}
	else
	{
		UpdateOffhandRuiVisibility( file.dpad_left_hud, "%weaponSelectOrdnance%" )
	}
}

void function InitWeaponStatusRuis( entity player )
{
	player.Signal( "EndTrackOffhandWeaponSlot" )

	UpdateOffhandRuis( player )

	if ( player.IsTitan() )
	{
		thread TrackOffhandWeaponSlot( player, file.ability_left_hud, OFFHAND_LEFT )
		thread TrackOffhandWeaponSlot( player, file.ability_center_hud, OFFHAND_TITAN_CENTER )
		thread TrackOffhandWeaponSlot( player, file.ability_right_hud, OFFHAND_RIGHT )
		if ( IsMultiplayer() )
			thread TrackOffhandWeaponSlot( player, file.dpad_left_hud, OFFHAND_INVENTORY )
	}
	else
	{
		thread TrackOffhandWeaponSlot( player, file.ability_left_hud, OFFHAND_LEFT )
		thread TrackOffhandWeaponSlot( player, file.ability_center_hud, OFFHAND_RIGHT )
		if ( IsMultiplayer() )
		{
			thread TrackOffhandWeaponSlot( player, file.dpad_left_hud, OFFHAND_INVENTORY )
			//thread TrackHoldToSwapSlot( player, file.ammo_counter )
		}
		else
		{
			thread TrackATWeaponSlot( player, file.dpad_left_hud )
		}
		RuiSetBool( file.ability_right_hud, "isVisible", false )
	}
}

void function UpdateOffhandRuiVisibility( var rui, string hintText )
{
	if ( GetConVarInt( "hud_setting_showButtonHints" ) != 0 )
		RuiSetString( rui, "hintText", hintText )
	else
		RuiSetString( rui, "hintText", "" )
}

void function TrackHoldToSwapSlot( entity player, var rui )
{
	player.EndSignal( "EndTrackOffhandWeaponSlot" )
	player.EndSignal( "OnDeath" )

	OnThreadEnd(
		function() : ( rui )
		{
			//RuiSetBool( rui, "isVisible", false )
		}
	)

	float holdWeaponSwapTime = GetConVarFloat( "holdWeaponSwapTime" )
	RuiSetFloat( rui, "holdWeaponSwapTime", holdWeaponSwapTime )
	RuiSetFloat( rui, "holdTime", 0.0 )
	RuiSetBool( rui, "holdHintVisible", false )

	entity lastWeapon = null
	bool holdWeaponActive = false
	bool lastIsHolding = false
	float holdChangeTime = 0.0
	while ( IsAlive( player ) )
	{
		entity activeWeapon = player.GetActiveWeapon()
		if ( activeWeapon != lastWeapon )
		{
			array<entity> mainWeapons = player.GetMainWeapons()
			if ( mainWeapons.len() > 2 )
			{
				if ( mainWeapons[2] == activeWeapon )
				{
					holdWeaponActive = true
				}
				else
				{
					holdWeaponActive = false
				}
			}
		}

		if ( !holdWeaponActive )
		{
			bool isHolding = player.IsInputCommandHeld( IN_WEAPON_CYCLE )
			if ( isHolding != lastIsHolding )
				holdChangeTime = Time()

			if ( isHolding )
			{
				RuiSetFloat( rui, "holdTime", Time() - holdChangeTime )
			}
			else
			{
				RuiSetFloat( rui, "holdTime", 0.0 )
			}
			lastIsHolding = isHolding
		}
		else
		{
			RuiSetFloat( rui, "holdTime", 0.0 )
		}
		RuiSetBool( rui, "holdHintVisible", IsControllerModeActive() )

		lastWeapon = activeWeapon
		WaitFrame()
	}
}

void function TrackOffhandWeaponSlot( entity player, var rui, int slot )
{
	player.EndSignal( "EndTrackOffhandWeaponSlot" )
	player.EndSignal( "OnDeath" )

	OnThreadEnd(
		function() : ( rui )
		{
			RuiSetBool( rui, "isVisible", false )
		}
	)

	entity lastWeapon = null
	bool wasVisible = file.slotVisible[slot]
	while ( IsAlive( player ) )
	{
		entity weapon = player.GetOffhandWeapon( slot )
		if ( weapon != lastWeapon || file.slotVisible[slot] != wasVisible )
		{
			if ( IsValid( weapon ) && file.slotVisible[slot] )
			{
				InitOffhandRui( rui, player, weapon )
				#if MP
					if ( slot == OFFHAND_INVENTORY )
					{
						if ( player.IsTitan() )
						{
							int segments = player.GetWeaponAmmoStockpile( player.GetOffhandWeapon( OFFHAND_INVENTORY ) )
							segments += player.GetOffhandWeapon( OFFHAND_INVENTORY ).GetWeaponPrimaryClipCount()
							RuiSetInt( rui, "segments", segments )
							RuiSetFloat( rui, "minFireFrac", 0.01 )
						}
						else
						{
							//RuiSetInt( rui, "segments", PlayerInventory_ItemCount( player ) )
							RuiTrackInt( rui, "segments", player, RUI_TRACK_SCRIPT_NETWORK_VAR_INT, GetNetworkedVariableIndex( "itemInventoryCount" ) )
							RuiSetFloat( rui, "minFireFrac", 0.01 )
						}
					}
				#elseif SP
					if ( slot == OFFHAND_INVENTORY )
					{
						RuiSetInt( rui, "segments", 1 )
						RuiSetFloat( rui, "minFireFrac", 0.01 )
					}
				#endif
			}
			else
			{
				RuiSetBool( rui, "isVisible", false )
			}
		}
		#if MP
		if ( slot == OFFHAND_INVENTORY && file.slotVisible[slot] && player.IsTitan() && IsValid( weapon ) )
		{
			int segments = player.GetWeaponAmmoStockpile( player.GetOffhandWeapon( OFFHAND_INVENTORY ) )
			segments += player.GetOffhandWeapon( OFFHAND_INVENTORY ).GetWeaponPrimaryClipCount()
			RuiSetInt( rui, "segments", segments )
			RuiSetFloat( rui, "minFireFrac", 0.01 )
		}
		#endif

		lastWeapon = weapon
		wasVisible = file.slotVisible[slot]
		WaitFrame()
	}
}

void function TrackATWeaponSlot( entity player, var rui )
{
	player.EndSignal( "EndTrackOffhandWeaponSlot" )
	player.EndSignal( "OnDeath" )

	OnThreadEnd(
		function() : ( rui )
		{
			RuiSetBool( rui, "isVisible", false )
		}
	)

	entity lastWeapon = null
	bool wasVisible = file.slotVisible[OFFHAND_INVENTORY]
	bool wasHoldingWeapon = player.GetActiveWeapon() == player.GetAntiTitanWeapon()
	while ( IsAlive( player ) )
	{
		entity weapon = player.GetAntiTitanWeapon()
		entity activeWeapon = player.GetActiveWeapon()
		bool isHoldingWeapon = weapon == activeWeapon
		if ( weapon != lastWeapon || file.slotVisible[OFFHAND_INVENTORY] != wasVisible || isHoldingWeapon != wasHoldingWeapon )
		{
			if ( IsValid( weapon ) && file.slotVisible[OFFHAND_INVENTORY] && !isHoldingWeapon )
			{
				InitOffhandRui( rui, player, weapon )
				RuiSetFloat2( rui, "iconSizeScale", <1.5,0.75,0> )
			}
			else
			{
				RuiSetBool( rui, "isVisible", false )
			}
		}

		lastWeapon = weapon
		wasVisible = file.slotVisible[OFFHAND_INVENTORY]
		wasHoldingWeapon = isHoldingWeapon
		WaitFrame()
	}
}
/*
	// VECTOR TYPES
	RUI_TRACK_ABSORIGIN_FOLLOW,						// Create at absorigin, and update to follow the entity
	RUI_TRACK_POINT_FOLLOW,							// Create on attachment point, and update to follow the entity
	RUI_TRACK_OVERHEAD_FOLLOW,						// Create at the top of the entity's bbox
	RUI_TRACK_EYEANGLES_FOLLOW,

	// FLOAT TYPES
	RUI_TRACK_HEALTH,								// Health as fraction from 0 to 1
	RUI_TRACK_FRIENDLINESS,							// 0 if ent is enemy, 1 if it's friendly
	RUI_TRACK_PLAYER_SUIT_POWER,					// Player's suit power from 0 to 1
	RUI_TRACK_PLAYER_GRAPPLE_POWER,					// Player's grapple power from 0 to 1
	RUI_TRACK_PLAYER_SHARED_ENERGY,					// Players shared energy value
	RUI_TRACK_WEAPON_CHARGE_FRACTION,				// Weapon charge as fraction from 0 to 1
	RUI_TRACK_WEAPON_SMART_AMMO_LOCK_FRACTION,		// Smart ammo weapon lock fraction from 0 to N
	RUI_TRACK_WEAPON_READY_TO_FIRE_FRACTION,		// Weapon cooldown as fraction from 0 to 1
	RUI_TRACK_WEAPON_RELOAD_FRACTION,				// Weapon reloading as fraction from 0 to 1
	RUI_TRACK_WEAPON_DRYFIRE_FRACTION,				//
	RUI_TRACK_WEAPON_CLIP_AMMO_FRACTION,			// Weapon clip ammo as fraction from 0 to 1
	RUI_TRACK_WEAPON_REMAINING_AMMO_FRACTION,		// Weapon remaining ammo as fraction from 0 to 1
	RUI_TRACK_WEAPON_CLIP_AMMO_MAX,					//
	RUI_TRACK_WEAPON_STOCKPILE_AMMO_MAX,			//
	RUI_TRACK_WEAPON_LIFETIME_SHOTS,				//
	RUI_TRACK_WEAPON_AMMO_REGEN_RATE,				//
	RUI_TRACK_BOOST_METER_FRACTION,					// Player boost meter as fraction from 0 to 1
	RUI_TRACK_GLIDE_METER_FRACTION,					// Player glide meter as fraction from 0 to 1
	RUI_TRACK_SHIELD_FRACTION,						// Shield health as fraction from 0 to 1
	RUI_TRACK_STATUS_EFFECT_SEVERITY,				// Status effect severity as fraction from 0 to 1; attachmentIndex used as status effect index
	RUI_TRACK_SCRIPT_NETWORK_VAR,					// Value of a script network variable (use GetNetworkedVariableIndex())
	RUI_TRACK_SCRIPT_NETWORK_VAR_GLOBAL,			// Value of a script network variable without an entity (use GetNetworkedVariableIndex())
	RUI_TRACK_SCRIPT_NETWORK_VAR_LOCAL_VIEW_PLAYER,	// Value of a script network variable on the local view player (changes automatically during kill replay) (use GetNetworkedVariableIndex())
	RUI_TRACK_FRIENDLY_TEAM_SCORE,					//
	RUI_TRACK_FRIENDLY_TEAM_ROUND_SCORE,			// The value of score2 for friendlies
	RUI_TRACK_ENEMY_TEAM_SCORE,						//
	RUI_TRACK_ENEMY_TEAM_ROUND_SCORE,				// The value of score2 for enemies
	RUI_TRACK_MINIMAP_SCALE,						//
	RUI_TRACK_SOUND_METER,							// Sound meter as fraction from 0 to 1.

	// INT TYPES
	RUI_TRACK_MINIMAP_FLAGS,
	RUI_TRACK_MINIMAP_CUSTOM_STATE,
	RUI_TRACK_TEAM_RELATION_VIEWPLAYER,					// ENEMY: -1, NEUTRAL: 0, FRIENDLY: 1
	RUI_TRACK_TEAM_RELATION_CLIENTPLAYER,				// ENEMY: -1, NEUTRAL: 0, FRIENDLY: 1
	RUI_TRACK_SCRIPT_NETWORK_VAR_INT,					// Value of a script network variable (use GetNetworkedVariableIndex())
	RUI_TRACK_SCRIPT_NETWORK_VAR_GLOBAL_INT,			// Value of a script network variable without an entity (use GetNetworkedVariableIndex())
	RUI_TRACK_SCRIPT_NETWORK_VAR_LOCAL_VIEW_PLAYER_INT,	// Value of a script network variable on the local view player (changes automatically during kill replay) (use GetNetworkedVariableIndex())

	// GAMETIME TYPES
	RUI_TRACK_LAST_FIRED_TIME,
	RUI_TRACK_MINIMAP_THREAT_SECTOR,

	// IMAGE TYPES
	RUI_TRACK_WEAPON_MENU_ICON,
	RUI_TRACK_WEAPON_HUD_ICON,
*/

void function InitOffhandRui( var rui, entity player, entity weapon )
{
	RuiSetGameTime( rui, "hintTime", Time() )

	RuiSetBool( rui, "isTitan", player.IsTitan() )
	RuiSetBool( rui, "isVisible", true )
	RuiSetBool( rui, "isReverseCharge", false )

	RuiSetFloat( rui, "chargeFrac", 0.0 )
	RuiSetFloat( rui, "useFrac", 0.0 )
	RuiSetFloat( rui, "chargeMaxFrac", 1.0 )
	RuiSetFloat( rui, "minFireFrac", 1.0 )
	RuiSetInt( rui, "segments", 1 )
	RuiSetFloat( rui, "refillRate", 1 ) // default to 1 to preserve default behavior. some abilities draw the refillRecharge, even without a rate setting

	RuiTrackImage( rui, "hudIcon", weapon, RUI_TRACK_WEAPON_HUD_ICON )

	RuiTrackFloat( rui, "readyFrac", weapon, RUI_TRACK_WEAPON_READY_TO_FIRE_FRACTION )
	RuiTrackFloat( rui, "dryfireFrac", weapon, RUI_TRACK_WEAPON_DRYFIRE_FRACTION )

	RuiSetFloat( rui, "chargeFracCaution", 0.0 )
	RuiSetFloat( rui, "chargeFracAlert", 0.0 )
	RuiSetFloat( rui, "chargeFracAlertSpeed", 16.0 )
	RuiSetFloat( rui, "chargeFracAlertScale", 1.0 )

	switch ( weapon.GetWeaponInfoFileKeyField( "cooldown_type" ) )
	{
		case "ammo":
			int ammoClipSize = weapon.GetWeaponSettingInt( eWeaponVar.ammo_clip_size )
			int ammoPerShot = weapon.GetWeaponSettingInt( eWeaponVar.ammo_per_shot )
			int ammoMinToFire = weapon.GetWeaponSettingInt( eWeaponVar.ammo_min_to_fire )

			RuiSetFloat( rui, "minFireFrac", float (  ammoMinToFire ) / float ( ammoClipSize ) )
			RuiSetInt( rui, "segments", ammoClipSize / ammoPerShot )

			RuiTrackFloat( rui, "chargeFrac", weapon, RUI_TRACK_WEAPON_CLIP_AMMO_FRACTION )

			RuiSetFloat( rui, "refillRate", weapon.GetWeaponSettingFloat( eWeaponVar.regen_ammo_refill_rate ) )
			break

		case "ammo_swordblock":
			RuiTrackFloat( rui, "chargeFrac", weapon, RUI_TRACK_WEAPON_STOCKPILE_REGEN_FRAC )
			RuiSetFloat( rui, "readyFrac", 0.0 )
			RuiSetFloat( rui, "minFireFrac", 0.0 )

			RuiSetFloat( rui, "chargeFracCaution", 0.6 )
			RuiSetFloat( rui, "chargeFracAlert", 0.0 )
			break

		case "ammo_alert":
			RuiSetFloat( rui, "chargeFrac", 0.0 )
			RuiSetFloat( rui, "readyFrac", 0.0 )
			RuiSetFloat( rui, "minFireFrac", 0.0 )

			RuiSetFloat( rui, "chargeFracCaution", 0.01 )
			RuiSetFloat( rui, "chargeFracAlert", -1.0 )
			RuiSetFloat( rui, "chargeFracAlertSpeed", 5.0 )
			RuiSetFloat( rui, "chargeFracAlertScale", 0.6 )
			break

		case "ammo_instant":
		case "ammo_deployed":
			int ammoClipSize = weapon.GetWeaponSettingInt( eWeaponVar.ammo_clip_size )
			int ammoPerShot = weapon.GetWeaponSettingInt( eWeaponVar.ammo_per_shot )
			int ammoMinToFire = weapon.GetWeaponSettingInt( eWeaponVar.ammo_min_to_fire )

			RuiSetFloat( rui, "minFireFrac", float (  ammoMinToFire ) / float ( ammoClipSize ) )
			RuiSetInt( rui, "segments", ammoClipSize / ammoPerShot )

			RuiTrackFloat( rui, "chargeFrac", weapon, RUI_TRACK_WEAPON_CLIP_AMMO_FRACTION )
			RuiSetFloat( rui, "readyFrac", 0.0 )

			RuiSetFloat( rui, "refillRate", weapon.GetWeaponSettingFloat( eWeaponVar.regen_ammo_refill_rate ) )
			break

		case "ammo_per_shot":
			int ammoClipSize = weapon.GetWeaponSettingInt( eWeaponVar.ammo_clip_size )
			int ammoPerShot = weapon.GetWeaponSettingInt( eWeaponVar.ammo_per_shot )
			int ammoMinToFire = weapon.GetWeaponSettingInt( eWeaponVar.ammo_min_to_fire )

			RuiSetFloat( rui, "minFireFrac", float (  ammoMinToFire ) / float ( ammoClipSize ) )
			RuiSetInt( rui, "segments", 1 )

			RuiTrackFloat( rui, "chargeFrac", weapon, RUI_TRACK_WEAPON_CLIP_AMMO_FRACTION )
			RuiSetFloat( rui, "readyFrac", 0.0 )

			RuiSetFloat( rui, "refillRate", weapon.GetWeaponSettingFloat( eWeaponVar.regen_ammo_refill_rate ) )
			break

		case "ammo_timed":
			int ammoClipSize = weapon.GetWeaponSettingInt( eWeaponVar.ammo_clip_size )
			int ammoPerShot = weapon.GetWeaponSettingInt( eWeaponVar.ammo_per_shot )
			int ammoMinToFire = weapon.GetWeaponSettingInt( eWeaponVar.ammo_min_to_fire )

			RuiSetFloat( rui, "minFireFrac", float (  ammoMinToFire ) / float ( ammoClipSize ) )
			RuiSetInt( rui, "segments", ammoClipSize / ammoPerShot )

			RuiTrackFloat( rui, "chargeFrac", weapon, RUI_TRACK_WEAPON_CLIP_AMMO_FRACTION )
			RuiSetFloat( rui, "readyFrac", 0.0 )

			RuiTrackFloat( rui, "useFrac", weapon, RUI_TRACK_STATUS_EFFECT_SEVERITY, eStatusEffect.simple_timer )

			RuiSetFloat( rui, "refillRate", weapon.GetWeaponSettingFloat( eWeaponVar.regen_ammo_refill_rate ) )
			break

		case "shared_energy":
			int curCost = weapon.GetWeaponCurrentEnergyCost() // 350

			RuiSetFloat( rui, "readyFrac", 0.0 )
			RuiSetFloat( rui, "chargeMaxFrac", float( curCost ) )
			RuiTrackFloat( rui, "chargeFrac", player, RUI_TRACK_PLAYER_SHARED_ENERGY )
			break

		case "shared_energy_drain":
			RuiSetFloat( rui, "readyFrac", 0.0 )
			RuiSetFloat( rui, "minFireFrac", 0.0 )
			RuiTrackFloat( rui, "chargeFrac", player, RUI_TRACK_PLAYER_SHARED_ENERGY )
			RuiSetFloat( rui, "chargeMaxFrac", float( ION_ENERGY_MAX ) )
			break

		case "vortex_drain":
			RuiSetBool( rui, "isReverseCharge", true )
			RuiSetFloat( rui, "chargeFrac", 1.0 )
			RuiSetFloat( rui, "readyFrac", 0.0 )
			RuiSetFloat( rui, "minFireFrac", 0.0 )

			RuiTrackFloat( rui, "chargeFrac", weapon, RUI_TRACK_WEAPON_CHARGE_FRACTION )
			break

		case "charged_shot":
			RuiSetBool( rui, "isReverseCharge", true )
			RuiSetFloat( rui, "chargeFrac", 1.0 )
			RuiSetFloat( rui, "readyFrac", 0.0 )
			RuiSetFloat( rui, "minFireFrac", 0.2 )

			RuiTrackFloat( rui, "chargeFrac", weapon, RUI_TRACK_WEAPON_CHARGE_FRACTION )
			break

		case "chargeFrac":
			RuiTrackFloat( rui, "chargeFrac", weapon, RUI_TRACK_WEAPON_CHARGE_FRACTION )
			break

		case "smart":
			RuiSetBool( rui, "isReverseCharge", true )
			RuiTrackFloat( rui, "chargeFrac", weapon, RUI_TRACK_WEAPON_CHARGE_FRACTION )
			RuiSetFloat( rui, "readyFrac", 0.0 )
			RuiTrackFloat( rui, "dryfireFrac", weapon, RUI_TRACK_WEAPON_DRYFIRE_FRACTION )
			break

		case "debug":
			RuiTrackFloat( rui, "chargeFrac", weapon, RUI_TRACK_WEAPON_CHARGE_FRACTION )
			RuiTrackFloat( rui, "readyFrac", weapon, RUI_TRACK_WEAPON_READY_TO_FIRE_FRACTION )
			//RuiTrackFloat( rui, "dryfireFrac", weapon, RUI_TRACK_WEAPON_DRYFIRE_FRACTION )
			RuiTrackFloat( rui, "dryfireFrac", weapon, RUI_TRACK_WEAPON_SMART_AMMO_LOCK_FRACTION )
			break

		case "grapple":
			int ammoClipSize = 100
			float ammoMinToFire = weapon.GetWeaponSettingFloat( eWeaponVar.grapple_power_required )

			RuiSetFloat( rui, "minFireFrac", ammoMinToFire / float ( ammoClipSize ) )
			RuiSetInt( rui, "segments", int( ammoClipSize / ammoMinToFire ) )
			RuiTrackFloat( rui, "chargeFrac", player, RUI_TRACK_PLAYER_GRAPPLE_POWER )
			break

		default:
			float refillRate = weapon.GetWeaponSettingFloat( eWeaponVar.regen_ammo_refill_rate )

			if ( refillRate > 0 )
			{
				//printt( "HUD: ", weapon.GetWeaponClassName(), "using", "refillRate" )
				int ammoClipSize = weapon.GetWeaponSettingInt( eWeaponVar.ammo_clip_size )
				int ammoPerShot = weapon.GetWeaponSettingInt( eWeaponVar.ammo_per_shot )
				int ammoMinToFire = weapon.GetWeaponSettingInt( eWeaponVar.ammo_min_to_fire )

				RuiSetFloat( rui, "minFireFrac", float (  ammoMinToFire ) / float ( ammoClipSize ) )
				RuiSetInt( rui, "segments", ammoClipSize / ammoPerShot )

				RuiTrackFloat( rui, "chargeFrac", weapon, RUI_TRACK_WEAPON_CLIP_AMMO_FRACTION )
			}
			else
			{
				float chargeTime = weapon.GetWeaponSettingFloat( eWeaponVar.charge_time )
				if ( chargeTime == 0 )
				{
					//printt( "HUD: ", weapon.GetWeaponClassName(), "using", "chargeTime == 0" )
					float fireDuration = weapon.GetWeaponSettingFloat( eWeaponVar.fire_duration )
					printt( weapon.GetWeaponClassName(), fireDuration )
					RuiSetBool( rui, "isReverseCharge", true )
					RuiTrackFloat( rui, "chargeFrac", weapon, RUI_TRACK_WEAPON_READY_TO_FIRE_FRACTION )
				}
				else
				{
					//printt( "HUD: ", weapon.GetWeaponClassName(), "using", "chargeTime" )
					RuiTrackFloat( rui, "chargeFrac", weapon, RUI_TRACK_WEAPON_CHARGE_FRACTION )
				}
			}
			break
	}
}



void function ClWeaponStatus_SetOffhandVisible( int offhandIndex, bool newState )
{
	entity player = GetLocalClientPlayer()

	var rui = GetRuiForIndex( player, offhandIndex )

	file.slotVisible[offhandIndex] = newState
	RuiSetBool( rui, "isVisible", newState )
}

var function GetRuiForIndex( entity player, int offhandIndex )
{
	var rui

	if ( player.IsTitan() )
	{
		switch ( offhandIndex )
		{
			case OFFHAND_LEFT:
				rui = file.ability_left_hud
				break
			case OFFHAND_TITAN_CENTER:
				rui = file.ability_center_hud
				break
			case OFFHAND_RIGHT:
				rui = file.ability_right_hud
				break
			case OFFHAND_INVENTORY:
				rui = file.dpad_left_hud
				break
		}
	}
	else
	{
		switch ( offhandIndex )
		{
			case OFFHAND_LEFT:
				rui = file.ability_left_hud
				break
			case OFFHAND_RIGHT:
				rui = file.ability_center_hud
				break
			case OFFHAND_INVENTORY:
				rui = file.dpad_left_hud
				break
		}
	}

	return rui
}

void function ClWeaponStatus_SetWeaponVisible( bool newState )
{
	RuiSetBool( file.ammo_counter, "isVisible", newState )
	file.ammo_counter_visible = newState
}

vector function GetAccentColor(bool boost = false)
{
	return (boost ? GetConVarFloat3("comp_hud_boost_text_color") / 255.0 : GetConVarFloat3("comp_hud_accent_color") / 255.0)
}